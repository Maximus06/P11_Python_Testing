
TD.io :
TDD
https://testdriven.io/blog/modern-tdd/

Flask pytest
https://testdriven.io/blog/flask-pytest/

Pytest sur Realpython
https://realpython.com/pytest-python-testing/

Http status:
https://developer.mozilla.org/fr/docs/Web/HTTP/Status

*********************************************************************************************************
exemple du cours sur github:
https://github.com/OpenClassrooms-Student-Center/4425126-testing-python-flask/tree/pytest-test/tests
*********************************************************************************************************

Thierry sur unit et integration sous flask:
Le problème est souvent que beaucoup pensent en faire, alors qu'il font en fait des tests d'intégration.
Par exemple, il est pratiquement impossible en Flask de faire un test unitaire de vue. On obtient automatiquement
un test d'intégration dès qu'ont passe par le client de test. Flask ne permet pas en effet de se passer du client de test,
tandis que django oui. Maintenant, ce ne sont que des labels et dans une certaine mesure, ce n'est pas important.
De toute manière, dans la vrai vie, une vue ne devrait contenir que très peu de logique Il y a forcément cette zone grise lorsqu'on travaille avec un framework web entre test unitaire et test d'intégration.

***************************************************************************************************************
Diff unit test, integration test Aurélien Masse

Pour mieux comprendre la difference entre un test unitaire et un test d'integration:

Un test unitaire ne peut echouer qu'a cause du code testé ou du test en lui meme. Un test d'integration non.

Par exemple:
- une fonction qui fait appel a une base de donnees. Si je la teste c'est un test d'integration car mon code peut etre correct, mon test peut etre correct, mais le test peut echouer si la base de donnees n'est pas demaree.
- Une fonction faisant appel a une API, si je la teste, meme probleme meme si on code et mon test sont bons, le test echouera si l'API est innaccessible.
- Une fonction A qui contient un appel a une fonction B: Si on teste la fonction A il peut echouer a cause de la fonction B donc d'un code qu'on ne teste pas dans ce test precis, c'est un test d'integration

Donc si je fais des tests sur ces fonctions ce seront des tests d'integration pas des tests unitaires.

SAUF:
Pour tester unitairement une telle fonction on peut simuler la reussite de la partie qui peut poser probleme. Dans le cas de l'API par exemple je peux utiliser un mock. De cette facon, que l'API soit fonctionnelle ou pas, le mock retournera toujours ce qui est attendu. On a retiré le systeme tiers qui peut faire echouer mon test, mon test devient un test unitaire car il ne fait plus appel a l'API.
De meme si je mocke le resultat de ma fonction B dans ma fonction A (troisieme exemple) meme si ma fonction B n'est pas fonctionnelle, le test passera car la focntion A est correctement codée et independante de la fonction B (puisque sa reussite est simulee par le mock)

************************************************************************************************************************

locust:

ATTENTION: requete sur localhost bien plus lente que sur 127.0.0.1 (DNS ?)

ligne de commande :
locust --headless --users 6 --spawn-rate 1 -H http://127.0.0.1:5000/

server!
locust

lancer http://localhost:8089/

***********************************************************************************************************
Coverage

fichier .coveragerc:
# Pour omettre le dossier des tests dans le coverage
[run]
omit = 
    tests/*
    locustfile.py

avec coverage :
coverage run -m pytest -v tests
coverage report

avec pytest-cov :
pytest --cov=.  -v tests
Ou en générant un rapport html:
pytest --cov=. --cov-report html (générera un dossier htmlcov)

pytest en parrallèle :
pip install pytest-xdist

pytest -n 3

Pour la maitrise du temps -----------------------------------------
# https://pypi.org/project/freezegun/

from freezegun import freeze_time
import datetime
import unittest

# Freeze time for a pytest style test:

@freeze_time("2012-01-14")
def test():
    assert datetime.datetime.now() == datetime.datetime(2012, 1, 14)
--------------------------------------------------------------------